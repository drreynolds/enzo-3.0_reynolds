Usage Overview
##############

We have added support for simple, lightweight, timing and performance
measurements.  This allows one to examine which functions are using the majority
of the simulation runtime, and how this varies across multiple processors. We
have built in a number of default timers, such as EvolveLevel for each level,
RebuildHierarchy, SolveHydroEquations, and Gravity. Below, we will outline how
to add additional timers.

File Format
###########

At each cycle, information is printed out to a file named performance.out.
By default, for each timing section the times spent on each processor are 
collected, and the mean, standard deviation, minimum, and maximum values 
are presented.  This is meant to give the user a sense of how well 
load-balanced their simulation is across processors, as well as pinpoint
where the majority of the time is being spent.  To explain the output, we show
an example cycle:

| --------------------------example performance.out-----------------------------
| Cycle_Number 2
| Level_0 6.520748e-05 8.344650e-07 6.389618e-05 6.604195e-05 100 4 3.833916e+05
| Level_1 3.254414e-05 2.804866e-05 1.406670e-05 8.106232e-05 10 1 7.681875e+04
| Level_2 1.159906e-04 2.678922e-05 9.965897e-05 1.623631e-04 14 1 3.017485e+04
| Level_3 2.477765e-04 7.348677e-05 2.028942e-04 3.750324e-04 16 1 1.614358e+04
| Level_4 5.816817e-04 1.630557e-04 4.820824e-04 8.640289e-04 24 1 1.031492e+04
| Level_5 1.266718e-03 3.594168e-04 1.056910e-03 1.889229e-03 26 1 5.131371e+03
| Level_6 2.686501e-03 7.197988e-04 2.262831e-03 3.933191e-03 40 1 3.722315e+03
| RebuildHierarchy 5.715549e-03 1.371242e-04 5.478144e-03 5.801201e-03
| SolveHydroEquations 1.436710e-03 2.407243e-03 4.386902e-05 5.606174e-03
| Total 1.499003e-02 3.440975e-05 1.494408e-02 1.503992e-02 230 10 3.835882e+03
| ------------------------------------------------------------------------------

| Each of the Level_N and Total lines have:
| Level_N, mean time, std_dev time, min time, max time, number of cells, 
| number of grids, mean cells/s/processor

| Each non-level line (Rebuild Hierarchy, SolveHydroEquations, etc.) have:
| Section Name, mean time, std_dev time, min time, max time. 

Time is measured in seconds of wall time for each of the processors.

In the example above, we see that more time is being spent in RebuildHierarchy 
than in SolveHydroEquations, and that the load balance is quite poor for the
SolveHydroEquations where the mean is 1.4 ms, with a standard deviation of
2.4 ms. 

At the beginning of each simulation (on Cycle 1), we print out a header to the
performance.out file:

| # This file contains timing information
| # For instructions on how to decipher this information,
| # see http://enzo-project.org/docs/somewhere
| # Times are collected across MPI processes and presented as:
| # Level_N/Total, mean time, std_dev time, min time, max time, cells, grids,
| # cells/processor/sec
| # Routine, mean time, std_dev time, min time, max time

Then, at the start of each simulation (whether the beginning or a restart), we
print out the MPI processor count:

# Starting performance log. MPI processes: 4

This is done in case the number of processors changes over time.

Adding New Timers
#################

While there are a number of default timers, it is easy to add new timers to any
section of code in Enzo.

The built-in timers include: EvolveHierarchy (Total), EvolveLevel (for each 
level), Gravity, Hydro, RebuildHierarchy.  Adding new times should be as 
simple as doing two things:

1) Add #include "EnzoTiming.h" to the top of the file you want to profile,
making sure it is before macros_and_parameters.

2) Adding 
| TIMER_START("YourTimerName");
| and 
| TIMER_STOP("YourTimerName");
| around the code you want to time.  

The string that you pass in gets collected in a map which is then iterated over
at the end of each evolve hierarchy.  At that time it prints into a file named
performance.out.

Generating Plots
################

performance_tools.py is a python module for plotting the performance 
information stored in performance.out.  The easiest way to generate plots
from performance.out is to call performance_tools.py from the command line:

| $ python performance_tools.py performance.out
| 
| or 
| 
| $ python performance_tools.py -s 11 performance.out

to do the same while applying a smoothing kernel to your data 11 cycles in 
width.

By default, performance_tools.py will output 6 plots: 

--p1.png
Plot the mean time taken per processor on each level and on the 
simulation as a whole (Total) versus cycle number.  Overplot in 
gray the minimum and maximum time taken on a processor for each 
of these quantities.

--p2.png
Same as p1.png except scale everything to be as a fraction of the 
total time taken.

--p3.png
Plot the mean time taken per processor on each level versus cycle number.  
Stack each level on the previous layer cumulatively.  

--p4.png
Plot the mean time taken per processor performing the RebuildHiearchy
and SolveHydroEquations tasks versus cycle number.  Stack each level on 
the previous layer cumulatively.  Scale everything to be as a fraction of the
total time taken.

--p5.png
Plot the number of cells generated at each level versus cycle number and 
stack them cumulatively.

--p6.png
Plot the efficiency (cells/processor/sec) for each level and for
the simulation as a whole versus cycle number.

Generating Additional Plots
###########################

If you want to create additional plots of your data beyond the defaults, 
simply add new plot_quantities() and plot_stack() calls to the bottom of 
performance_tools.py.

This can be as simple as adding a line:

| $ p.plot_quantity("Level 0", "mean time")
| 
| or
| 
| $ p.plot_stack("Level 0", "mean time")

Here follows the full documentation for plot_quantity and plot_stack:

| def plot_quantity(self, field_label, y_field_index,
|                   y_field_axis_label="", x_field_index='cycle',
|                   x_field_axis_label="Cycle Number",
|                   filename="performance.png", repeated_field="",
|                   log_y_axis="Auto", smooth_len=0, bounds="Off",
|                   fractional=False):
|  
|     Produce a plot for the given quantity(s) from the performance data.
| 
|     Parameters
|     ----------
|     field_label : string or array_like of strings
|         The label of the field you wish to plot.  If you wish to plot
|         multiple fields, enumerate them in an array or tuple. Ex: "Level 0"
|     y_field_index : string
|         The index of the field you wish to plot on the y axis. 
|         Ex: "mean time", "std_dev time", "min time", "max time",
|         "cells", "grids", "cells/processor/sec".
|         If you have a single value for many field_labels, it is assumed
|         that such a value will index all of them.  If you have an array_like
|         structure of ints, each one will index the corresponding key in 
|         field_lable.  
|     y_field_axis_label : string, optional
|         The y axis label on the resulting plot. Default = the y_field_index
|         of the recarray.
|     x_field_index : string, optional
|         The index of the field you wish to plot on the x axis.
|         Default = "cycle"
|     x_field_axis_label : string, optional
|         The x axis label on the resulting plot. Default = "Cycle Number"
|     filename : string, optional
|         The filename where I will store your plotted data.
|     repeated_field : string, optional
|         If you have a regularly named set of fields you wish to plot 
|         against each other (e.g. "Level 0", "Level 1", "Level 2"), then
|         include the string here and they will all be included automatically
|         and in order (e.g. "Level").
|     log_y_axis : string, optional
|         This controls whether the plot will use logarithmic units for the
|         y axis.  Valid settings are "Auto", "On", and "Off".  When "Auto" is
|         used, the code automatically recognizes when you have a maximum 
|         y value more than 3 orders of magnitude greater than your minimum y
|         value (for non-zero values) at which point it plots the y axis in 
|         log units.
|     smooth_len : int, optional
|         This value controls the amount by which smoothing occurs over
|         N consecutive cycles of data.  Default = 0 (i.e. None). 
|         Must be an odd number (recommended 5-11)
|     bounds : string, optional
|         This controls whether to overplot additional bounding data over
|         the existing plotted quantities.  Valid values of this variable
|         are "minmax", "sigma" and "Off".  "minmax" overplots the minima and
|         maxima bounds, whereas "sigma" plots the mean +/- 1 sigma bounds.
|     fractional : bool, optional
|         When set to true, the plotted values shown in fractions of the 
|         equivalent field in "Total".
| 
|     Examples
|     --------
|     To produce a simple plot of the mean time taken over the course of 
|     the simulation to run the RebuildHierarchy section of code.
|     Save this plot to performance.png:
| 
|     >>> plot_quantity("RebuildHierarchy", "mean time")
| 
|     To produce a plot comparing the RebuildHiearchy and SolveHydroEquations
|     maximum time taken over the course of the simulation and save it 
|     to file "test.png":
| 
|     >>> plot_quantity(["RebuildHierarchy", "SolveHydroEquations"],
|     "max time", "Maximum Time (sec)", filename="test.png")
| 
|     To produce a plot comparing the maximum time from RebuildHiearchy and 
|     the minimum time from SolveHydroEquations taken over the course of the 
|     simulation and save it to file "test.png":
| 
|     >>> plot_quantity(["RebuildHierarchy", "SolveHydroEquations"],
|     ["max time", "min time"], "Time (sec)", filename="test.png")
| 
|     To produce a plot comparing the mean time taken by all of the different
|     levels over the course of the simulation and save it to file "test.png": 
|     >>> plot_quantity([], "mean time", "Mean Time (sec)", 
|     filename="test.png", repeated_field="Level")
|
| def plot_stack(self, field_label, y_field_index,
|                y_field_axis_label="", x_field_index='cycle',
|                x_field_axis_label="Cycle Number",
|                filename="performance.png", repeated_field="",
|                log_y_axis="Auto", smooth_len=0, fractional=False):
| 
|     Produce a plot for the given label/indices where each quantity is 
|     stacked on top of the previous quantity.
| 
|     Parameters
|     ----------
|     field_label : array_like of strings
|         The labels of the fields you wish to plot.  If you wish to plot
|         a single field, then use plot_quantity instead.
|     y_field_index : string or array_like of strings
|         The index of the field you wish to plot on the y axis. 
|         Ex: "mean time", "std_dev time", "min time", "max time",
|         "cells", "grids", "cells/processor/sec".
|         If you have a single value for many field_labels, it is assumed
|         that such a value will index all of them.  If you have an array_like
|         structure of ints, each one will index the corresponding key in 
|         field_lable.  
|     y_field_axis_label : string, optional
|         The y axis label on the resulting plot. Default = the y_field_index
|         of the recarray.
|     x_field_index : string, optional
|         The index of the field you wish to plot on the x axis.
|         Default = "cycle"
|     x_field_axis_label : string, optional
|         The x axis label on the resulting plot. Default = "Cycle Number"
|     filename : string, optional
|         The filename where I will store your plotted data.
|     repeated_field : string, optional
|         If you have a regularly named set of fields you wish to plot 
|         against each other (e.g. "Level 0", "Level 1", "Level 2"), then
|         include the string here and they will all be included automatically
|         and in order (e.g. "Level").
|     log_y_axis : string, optional
|         This controls whether the plot will use logarithmic units for the
|         y axis.  Valid settings are "Auto", "On", and "Off".  When "Auto" is
|         used, the code automatically recognizes when you have a maximum 
|         y value more than 3 orders of magnitude greater than your minimum y
|         value (for non-zero values) at which point it plots the y axis in 
|         log units.
|     smooth_len : int, optional
|         This value controls the amount by which smoothing occurs over
|         N consecutive cycles of data.  Default = 0 (i.e. None)
|         Must be an odd number (recommended 5-11)
|     fractional : bool, optional
|         When set to true, the plotted values shown in fractions of the 
|         equivalent field in "Total".
| 
|     See Also
|     --------
|     plot_quantity
| 
|     Examples
|     --------
|     >>> plot_stack(["Level 0", "Level 1", "Level 2"], "mean time")
